#!/bin/bash

## Constants
source /etc/abf/abf.conf

for sys_dir in $(package-query -Sf "%F" filesystem); do
	[[ ${REPO_DIR} = "/${sys_dir%/}" || -z ${REPO_DIR} || ${REPO_DIR} = '/' ]] && {
		echo "ERROR: \"${REPO_DIR}\" is not a valid value for REPO_DIR.\nCheck /etc/abf/abf.conf"
		exit 1
	}
done

build_pkgs() { repo_name=$1 ; arch=$2 ; packages=$3
	echo "Building packages ($packages) for ${repo_name} (${arch})..."
	tmp_abf=/tmp/abf && mkdir -p $tmp_abf
	repo_out=$(mktemp --tmpdir=${tmp_abf} -d abf.build.${repo_name}.$arch.XXX)
	repo_root=$VAR_DIR/repo
	repo_dest=$repo_root/$repo_name

	[[ -w $repo_root ]] || { echo "ERROR: $repo_root must be writable."; exit; }
	[[ -d ${repo_dest}/any ]] || mkdir -p ${repo_dest}/any
	[[ -d ${repo_dest}/$arch ]] || mkdir -p ${repo_dest}/$arch

	schroot -c abf-$arch -d /tmp -u root -- yaourt --export ${repo_out} --noconfirm -S ${packages}

	find ${repo_out} -name '*.pkg.tar.*' -printf "%f %p\n" | \
	while read pkg_file pkg_path; do
		read pkg_name pkg_ver pkg_arch <<< $(package-query -f "%n %v %a" -p $pkg_path)

		pkg_conf=$REPO_CONF/$repo_name/$pkg_name
		pkg_dest=${repo_dest}/$arch/$pkg_file
		pkg_dest_any=${repo_dest}/any/$pkg_file
		repo_db=${repo_dest}/$arch/${repo_name}.db.tar.gz

		if [[ $pkg_arch == 'any' ]]; then
			if [[ $(stat -c '%Y' $pkg_dest_any) == $(stat -c '%Y' $pkg_conf) ]]; then
				echo "Skipping $pkg_name in ${repo_name} (any) repository... "
				rm ${pkg_path}
			else
				echo "Moving $pkg_name to ${repo_name} (any) repository... "
				mv $pkg_path $pkg_dest_any
			fi
			ln -sf ../any/$pkg_file $pkg_dest
		else
			echo "Moving $pkg_name to ${repo_name} ($arch) repository... "
			mv -f $pkg_path $pkg_dest
		fi
		
		if [ -f $pkg_dest ]; then
			touch $pkg_conf
			touch -hc -r $pkg_conf $repo_dest/*/$pkg_name-$pkg_ver-*.pkg.tar.xz
			echo "Adding $pkg_name to ${repo_name} database... "
			repo-add -f -d $repo_db $pkg_dest || \
				echo "Failed to add $pkg_name to $repo_name"
		fi
	done

	rm -rf $repo_out
	rm -rf $tmp_abf
}

get_stale_pkgs() {
	cd $REPO_CONF
	while read pkg_name pkg_conf; do
		[[ -z $pkg_name ]] && continue
		repo_conf=$(dirname $pkg_conf)
		repo_name=$(basename $repo_conf)
		# Check ABS
		read abs_ver abs_file <<< $(package-query -S -f "%V %f" $pkg_name)
		[[ $abs_pkg_file ]] && {
			for arch in "${ARCH_AVAIL[@]}"; do
				[[ -f $REPO_DIR/$repo_name/$arch/$abs_pkg_file ]] || {
					echo $pkg_name && continue
				}
			done
		}

		# Then AUR
		read aur_ver aur_ts <<< $(package-query --aur --format "%v %L" $pkg_name)
		[[ ! -z $aur_ts ]] && ts_gt $aur_ts $(stat -c '%Y' $pkg_conf) && {
			echo $pkg_name && continue
		}
		for arch in "${ARCH_AVAIL[@]}"; do
			pkg_file=$(ls -1 $REPO_DIR/$repo_name/$arch/$pkg_name-$aur_ver-*.pkg.tar.xz 2>/dev/null)
			[[ ! -z $pkg_file && -f $(readlink -m $pkg_file) ]] || {
				echo $pkg_name && break
			}
			ts_gt $(stat -c '%Y' $pkg_conf) $(stat -c '%Y' "$pkg_file") && {
				echo $pkg_name && break
			}
		done
	done <<< "$(find $REPO_CONF -maxdepth 2 -mindepth 2 -printf "%f %P\n")"
}

clean_repos() {
	declare -A repo_files
	cd $REPO_DIR
	
	echo "Cleaning up repo directory structure..."

	while read repo_name; do
		[[ -d $REPO_CONF/$repo_name ]] || \
			rm -rf --one-file-system $repo_name
	done <<< "$(find $REPO_DIR -type d -mindepth 1 -maxdepth 1 -printf "%P\n")"
	
	while read arch_path; do
		[[ -v $arch_path ]] || continue
		arch_name=$(basename $arch_path)
		[[ $arch_name == 'any' ]] || \
		[[ $arch_name == 'i686' ]] || \
		[[ $arch_name == 'x86_64' ]] || \
			rm -rf --one-file-system $arch_path
	done <<< "$(find $REPO_DIR -mindepth 2 -maxdepth 2 -printf "%P\n")"
	
	while read db_path; do
		[[ -f $db_path ]] || continue
		db_arch=$(echo $(dirname $db_path) | tr '/' '-')
		repo_files[$db_arch]="$(repo_files $db_path)"
	done <<< "$(find $REPO_DIR -mindepth 3 -maxdepth 3 -name '*.db' -printf "%P\n")"
	
	echo "Cleaning up package and delta files..."
	while read pkg_path; do
		[[ -f $pkg_path || -L $pkg_path ]] || continue
		pkg_file=$(basename $pkg_path)
		pkg_arch=$(basename $(dirname $pkg_path))
		repo_name=$(dirname $(dirname $pkg_path))
		repo_db=$REPO_DIR/$repo_name/$pkg_arch/$repo_name.db.tar.gz
		pkg_name=$([[ $pkg_file =~ '.pkg.tar.xz' ]] && [[ -f $pkg_path ]] && package-query -Q -f "%n" -p $pkg_path)
		pkg_conf=$REPO_CONF/$repo_name/$pkg_name

		# remove packages with missing config
		[[ ! -z $pkg_name ]] && [[ ! -f $pkg_conf ]] && {
			echo "Removing orphan package $pkg_file"
			find $REPO_DIR/$repo_name/ -name '*.db.tar.gz' -exec \
				repo-remove {} $pkg_name \;
			rm -f $pkg_path
			continue
		}
		
		# remove broken links
		[[ -f $(readlink -m $pkg_path) ]] || {
			echo "Deleting broken link $pkg_path"
			rm -f $pkg_path
			continue
		}
		
		# keep db files, and files referenced in db files
		[[ $(basename "$pkg_file") =~ $repo_name\.db(\.tar\.gz){0,1} ]] && continue
		echo "${repo_files[$repo_name-$pkg_arch]}" | grep -qe "^$pkg_file$" && continue
		echo "${repo_deltas[$repo_name-$pkg_arch]}" | grep -qe "^$pkg_file$" && continue

		# keep link targets (any) referenced from other repo dirs
		[[ $pkg_arch == 'any' ]] && [[ ! -z $(find $REPO_DIR -type l -name $pkg_file) ]] && \
			continue
		
		# delete everything else
		echo Deleting $pkg_path...
		rm -rf "$pkg_path"
	done <<< "$(find $REPO_DIR -mindepth 3 -maxdepth 3 -printf "%P\n")"
	
	find $REPO_DIR -name '*.db*.old' -delete
	
	echo "Cleanup complete."
}

pkgbuild_mod() {
	echo "Processing modification request for \"$1\"..."
}

build_all() {
	packages=$(get_stale_pkgs | tr '\n' ' ')
	[[ "$packages" ]] && {
		for arch in "${ARCH_AVAIL[@]}"; do
			 build_pkgs aurbin $arch "$packages"
		done
	} || echo "No package found for building."
}

rebuild_chroots() {
	echo "Umounting chroots image..."
	umount -f $VAR_DIR/chroots
	rm -rf $VAR_DIR/chroots*
	echo "Testing chroots..."
	test_chroots
}

test_chroots() {
	for arch in "${ARCH_AVAIL[@]}"; do
		echo "Booting $arch chroot..."
		schroot -c abf-$arch -d /tmp -- uname -a && yaourt --version || true
	done
}

repo_files() {
	db_file=$1
	db_name=$(basename $(basename $1 .db) .db.tar.gz)
	[[ -f $db_file ]] || db_file=$(readlink -m $REPO_DIR/$db_name/$1)
	[[ -f $db_file ]] || db_file=$(readlink -m $REPO_DIR/$db_name/$1.db)
	[[ -f $db_file ]] || { echo ERROR: $db_file not found; exit 1; }
	
	db_dir=$(mktemp --tmpdir -d abf.$db_name.XXX)
	tar -xf $db_file -C $db_dir
	cd $db_dir

	while read pkg_file; do
		echo $pkg_file
	done <<< "$(find $db_dir -type f -name 'desc' -exec awk '/%FILENAME%/{getline; print}' {} \;)"

	while read delta_file checksum size delta_from delta_to; do
		echo $delta_file
	done <<< "$(find $db_dir -type f -name 'deltas' -exec grep -v '%DELTAS%' {} \;)"
	
	rm -rf $db_dir
}

ts_gt() {
	ts_tar=$1; ts_ref=$2; lag_local=$[$ts_tar-$ts_ref]
	[[ $lag_local -gt 0 ]] && return 0
}

ts_eq() {
	ts_tar=$1; ts_ref=$2; lag_local=$[$ts_tar-$ts_ref]
	[[ $lag_local -eq 0 ]] && return 0
}

#get_stale_pkgs
#build_pkgs "tiobench yaourt" aurbin i686
build_all
clean_repos
#rebuild_chroots
#test_chroots
#repo_files x86_64/aurbin
#repo_files i686/aurbin
