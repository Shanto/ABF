#!/bin/bash
#
# ABF: ABS+AUR Build Factory for Arch Linux
#
# Copyright (c) 2011 Shanto <shanto@hotmail.com>
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU Library General Public License as published
# by the Free Software Foundation; either version 2, or (at your option)
# any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

NAME='abf'
VERSION='0.1'

build_pkgs() { repo_name=$1 ; arch=$2 ; packages=$3
	echo "Building packages ($packages) for ${repo_name} (${arch})..."
	tmp_abf=/tmp/abf && mkdir -p $tmp_abf
	repo_out=$(mktemp --tmpdir=${tmp_abf} -d ${repo_name}.$arch.XXX)
	repo_root=$VAR_DIR/repo
	repo_dest=$repo_root/$repo_name

	[[ -w $repo_root ]] || { echo "ERROR: $repo_root must be writable."; exit; }
	[[ -w $tmp_abf ]] || { echo "ERROR: $tmp_abf must be writable."; exit; }
	[[ -d ${repo_dest}/any ]] || mkdir -p ${repo_dest}/any
	[[ -d ${repo_dest}/$arch ]] || mkdir -p ${repo_dest}/$arch

	schroot -c abf-$arch -d /tmp -u root -- yaourt --export ${repo_out} --noconfirm -S ${packages}

	find ${repo_out} -name '*.pkg.tar.*' -printf "%f %p\n" | \
	while read pkg_file pkg_path; do
		read pkg_name pkg_ver pkg_arch <<< $(package-query -f "%n %v %a" -p $pkg_path)

		pkg_conf=$REPO_CONF/$repo_name/$pkg_name
		pkg_dest=${repo_dest}/$arch/$pkg_file
		pkg_dest_any=${repo_dest}/any/$pkg_file
		repo_db=${repo_dest}/$arch/${repo_name}.db.tar.gz

		if [[ $pkg_arch == 'any' ]]; then
			if [[ $(stat -c '%Y' $pkg_dest_any) == $(stat -c '%Y' $pkg_conf) ]]; then
				echo "Skipping $pkg_name in ${repo_name} (any) repository... "
				rm ${pkg_path}
			else
				echo "Moving $pkg_name to ${repo_name} (any) repository... "
				mv $pkg_path $pkg_dest_any
			fi
			ln -sf ../any/$pkg_file $pkg_dest
		else
			echo "Moving $pkg_name to ${repo_name} ($arch) repository... "
			mv -f $pkg_path $pkg_dest
		fi
		
		if [ -f $pkg_dest ]; then
			touch $pkg_conf
			touch -hc -r $pkg_conf $repo_dest/*/$pkg_name-$pkg_ver-*.pkg.tar.*
			echo "Adding $pkg_name to ${repo_name} database... "
			repo-add -f -d $repo_db $pkg_dest || \
				echo "Failed to add $pkg_name to $repo_name"
		fi
	done

	rm -rf $repo_out
	rm -rf $tmp_abf
}

get_stale_pkgs() {
	abs_dir=$(mktemp --tmpdir=/tmp -d abs.XXX)
	cd $REPO_CONF
	while read pkg_name pkg_conf; do
		[[ -n $pkg_name ]] || continue
		repo_conf=$(dirname $pkg_conf)
		repo_name=$(basename $repo_conf)

		# Check ABS
		read abs_ver abs_pkg abs_repo <<< $(package-query -S -f "%V %f %r" $pkg_name)
		abs_dir=$ABS_DIR/$abs_repo/$pkg_name
		[[ $abs_pkg_file ]] && {
			# missing package file for any arch?
			for arch in "${ARCH_AVAIL[@]}"; do
				[[ -f $REPO_DIR/$repo_name/$arch/$abs_pkg ]] || {
					echo $pkg_name && continue
				}
			done
			# timestamp comparison against ABS
			$ABSROOT=$abs_dir abs $abs_repo/$pkg_name
			[[ -n $(find $abs_dir -cnewer $pkg_conf) ]] && {
				echo $pkg_name && continue
			}
		}

		# Then AUR
		read aur_ver aur_ts <<< $(package-query --aur --format "%v %L" $pkg_name)
		# timestamp comparison against AUR
		[[ -n $aur_ts ]] && ts_gt $aur_ts $(stat -c '%Y' $pkg_conf) && {
			echo $pkg_name && continue
		}
		
		# .pkg.tar.* file check
		pkg_ver=${abs_ver:=$aur_ver}
		for arch in "${ARCH_AVAIL[@]}"; do
			pkg_file=$(ls -1 $REPO_DIR/$repo_name/$arch/$pkg_name-$pkg_ver-*.pkg.tar.* 2>/dev/null)
			[[ ! -z $pkg_file && -f $(readlink -m $pkg_file) ]] || {
				echo $pkg_name && break
			}
			# timestamp comparison against pkg
			ts_gt $(stat -c '%Y' $pkg_conf) $(stat -c '%Y' "$pkg_file") && {
				echo $pkg_name && break
			}
		done
	done <<< "$(find $REPO_CONF -maxdepth 2 -mindepth 2 -printf "%f %P\n")"
	return 0
}

clean_repos() {
	declare -A repo_files
	cd $REPO_DIR
	
	echo "Cleaning up repo directory structure..."

	while read repo_name; do
		[[ -d $REPO_CONF/$repo_name ]] || \
			rm -rf --one-file-system $repo_name
	done <<< "$(find $REPO_DIR -type d -mindepth 1 -maxdepth 1 -printf "%P\n")"
	
	while read arch_path; do
		[[ -n $arch_path ]] || continue
		arch_name=$(basename $arch_path)
		[[ $arch_name == 'any' ]] || \
		[[ $arch_name == 'i686' ]] || \
		[[ $arch_name == 'x86_64' ]] || \
			rm -rf --one-file-system $arch_path
	done <<< "$(find $REPO_DIR -mindepth 2 -maxdepth 2 -printf "%P\n")"
	
	while read db_path; do
		[[ -f $db_path ]] || continue
		db_arch=$(echo $(dirname $db_path) | tr '/' '-')
		repo_files[$db_arch]="$(repo_query $db_path '%f %x' | tr ' ' '\n')"
	done <<< "$(find $REPO_DIR -mindepth 3 -maxdepth 3 -name '*.db' -printf "%P\n")"
	
	echo "Cleaning up package and delta files..."
	while read pkg_path; do
		[[ -n $pkg_path ]] || continue
		pkg_file=$(basename $pkg_path)
		repo_arch=$(basename $(dirname $pkg_path))
		repo_name=$(dirname $(dirname $pkg_path))
		repo_db=$REPO_DIR/$repo_name/$repo_arch/$repo_name.db.tar.gz
		pkg_name=$([[ $pkg_file =~ '.pkg.tar.xz' ]] && [[ -f $pkg_path ]] && package-query -Q -f "%n" -p $pkg_path)
		pkg_conf=$REPO_CONF/$repo_name/$pkg_name

		# remove packages with missing config
		[[ -n $pkg_name ]] && [[ ! -f $pkg_conf ]] && {
			echo "Removing orphan package $pkg_file"
			find $REPO_DIR/$repo_name/ -name '*.db.tar.gz' -exec \
				repo-remove {} $pkg_name \;
			rm -f $pkg_path
			continue
		}
		
		# remove broken links
		[[ -L $pkg_path && ! -f $(readlink -m $pkg_path) ]] && {
			echo "Deleting broken link $pkg_path"
			rm -f $pkg_path
			continue
		}
		
		[[ $repo_arch != 'any' && "$pkg_file" =~ .*-any.delta && ! -L "$pkg_path" ]] && {
			echo "Moving "$pkg_file" to any..."
			mv $pkg_path $REPO_DIR/$repo_name/any/
			ln -s ../any/$pkg_file $pkg_path
		}
		
		# keep db files, and files referenced in db files
		[[ "$pkg_file" =~ $repo_name\.db(\.tar\.gz)* ]] && continue
		echo "${repo_files[$repo_name-$repo_arch]}" | grep -qe "^$pkg_file$" && continue
		echo "${repo_deltas[$repo_name-$repo_arch]}" | grep -qe "^$pkg_file$" && continue

		# keep link targets (any) referenced from other repo dirs
		[[ $repo_arch == 'any' ]] && [[ ! -z $(find $REPO_DIR -type l -name $pkg_file) ]] && \
			continue
		
		# delete everything else
		echo Deleting $pkg_path...
		rm -rf "$pkg_path"
	done <<< "$(find $REPO_DIR -mindepth 3 -maxdepth 3 -printf "%P\n")"
	
	find $REPO_DIR -name '*.db*.old' -delete
	
	echo "Cleanup complete."
}

pkgbuild_mod() {
	echo "Processing modification request for \"$1\"..."
}

build_all() {
	packages=$(get_stale_pkgs | tr '\n' ' ')
	[[ "$packages" ]] && {
		for arch in "${ARCH_AVAIL[@]}"; do
			 build_pkgs aurbin $arch "$packages"
		done
	} || echo "No package found for building."
}

rebuild_chroots() {
	echo "Umounting chroots image..."
	umount -f $VAR_DIR/chroots
	rm -rf $VAR_DIR/chroots*
	echo "Testing chroots..."
	test_chroots
}

test_chroots() {
	for arch in "${ARCH_AVAIL[@]}"; do
		echo "Booting $arch chroot..."
		schroot -c abf-$arch -d /tmp -- uname -a && yaourt --version || true
	done
}

repo_query() { db_file=$1; format=$2
	format=${format:="%n %f %x"}
	db_name=$(basename $(basename $1 .db) .db.tar.gz)

	[[ -f $db_file ]] || db_file=$(readlink -m $REPO_DIR/$db_name/$1)
	[[ -f $db_file ]] || db_file=$(readlink -m $REPO_DIR/$db_name/$1.db)
	[[ -f $db_file ]] || { echo ERROR: $db_file not found; exit 1; }
	
	db_dir=$(mktemp --tmpdir -d abf.$db_name.XXX)
	tar -xf $db_file -C $db_dir
	cd $db_dir

	while read pkg_dir; do
		declare -A pkg_info
		pkg_info[n]=$(awk '/%NAME%/{getline; print}' "$pkg_dir/desc")
		pkg_info[f]=$(awk '/%FILENAME%/{getline; print}' "$pkg_dir/desc")
		pkg_info[x]=$([[ -f "$pkg_dir/deltas" ]] && grep -v '%DELTAS%' "$pkg_dir/deltas" | cut -d\  -f1)
		pkg_line=$format
		for i in n f x; do
			iv=${pkg_info[$i]}
			pkg_line=${pkg_line/\%$i/$iv}
		done
		pkg_line=${pkg_line//}
		[[ -n $pkg_line ]] && echo $pkg_line
	done <<< "$(find $db_dir -type d -mindepth 1 -maxdepth 1)"
	
	rm -rf $db_dir
}

ts_gt() {
	ts_tar=$1; ts_ref=$2; lag_local=$[$ts_tar-$ts_ref]
	[[ $lag_local -gt 0 ]] && return 0
}

ts_eq() {
	ts_tar=$1; ts_ref=$2; lag_local=$[$ts_tar-$ts_ref]
	[[ $lag_local -eq 0 ]] && return 0
}

print_help() { option=$1
	[[ -n $option ]] && cat <<-EOF
		Invalid Option: $option
		
	EOF
	cat <<-EOF
		Command Syntax: $NAME [options]
		
		  -a|--build-all
		       Check and build all missing and outdated packages.

		  -sc|--sample-config
		        Generate sample config files under $REPO_CONF.

		  --print-rebuildable
		         Scan AUR+ABS and print stale packages which need building.

		  --clean-repos
		       Scan $REPO_DIR for orphan or irrelevant files and clean them.

		  -h|--help
		         Print this help

		  Repo/package Config Management:

		  -qr|--repo-query repo-db-file [format]
		         Query and print the given repo db contents in given format.

		  -ap|--add-package repo-name packages
		        Add given packages under corresponding repo conf directory.

		  -rp|--remove-package repo-name packages
		        Remove given packages from corresponding repo conf directory.

		  -rr|--remove-repo repo-name
		        Remove given repo conf directory including all packages.

		  CHROOT Operations:

		    --update-chroots
		        Perform system update on base chroot images.

		    --rebuild-chroots
		        Destroy and rebuild chroots from fresh packages.

		    --test-chroots [command]
		        Test chroots with a pre-defined or given set of commands.
	EOF
	[[ -n $option ]] && exit 1
}

## Constants
source /etc/abf/abf.conf

for sys_dir in $(package-query -Sf "%F" filesystem); do
	[[ ${REPO_DIR} = "/${sys_dir%/}" || -z ${REPO_DIR} || ${REPO_DIR} = '/' ]] && {
		echo "ERROR: \"${REPO_DIR}\" is not a valid value for REPO_DIR.\nCheck /etc/abf/abf.conf"
		exit 1
	}
done

while [[ $1 ]]; do
	case "$1" in
		-sc|--sample-config) echo sc;;
		-h|--help)          print_help; exit 0;;
		*)                  print_help "$1";; 
	esac
	shift
done

get_stale_pkgs
#build_pkgs "tiobench yaourt" aurbin i686
#build_all
#clean_repos
#rebuild_chroots
#test_chroots
#repo_files x86_64/aurbin
#repo_query i686/aurbin
